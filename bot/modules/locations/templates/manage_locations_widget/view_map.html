<!-- Leaflet CSS -->
<link rel="stylesheet" href="/static/leaflet.css"/>

<style>
    #map {
        width: 100%;
        height: 100%;
        min-height: 400px;
        background: #1a1a1a;
        border: 2px solid var(--lcars-hopbush);
        border-radius: 8px;
        box-sizing: border-box;
    }
    main {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
    }
    .leaflet-container {
        background: #1a1a1a;
    }
    .location-marker {
        background-color: var(--lcars-golden-tanoi);
        border: 2px solid var(--lcars-tanoi);
        border-radius: 50%;
        width: 12px;
        height: 12px;
    }
    .player-marker {
        background-color: var(--lcars-anakiwa);
        border: 2px solid var(--lcars-mariner);
        border-radius: 50%;
        width: 10px;
        height: 10px;
    }
    .map-controls {
        margin-bottom: 10px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
    }

    /* Custom Legend Styling */
    .map-legend {
        background: rgba(26, 26, 26, 0.95);
        border: 2px solid var(--lcars-hopbush);
        border-radius: 8px;
        padding: 12px;
        font-family: monospace;
        font-size: 12px;
        line-height: 1.6;
        color: var(--lcars-golden-tanoi);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
        min-width: 200px;
    }
    .map-legend h4 {
        margin: 0 0 8px 0;
        color: var(--lcars-hopbush);
        font-size: 14px;
        font-weight: bold;
        border-bottom: 1px solid var(--lcars-hopbush);
        padding-bottom: 4px;
    }
    .map-legend .legend-item {
        margin: 4px 0;
        display: flex;
        justify-content: space-between;
        gap: 10px;
    }
    .map-legend .legend-label {
        color: var(--lcars-anakiwa);
        font-weight: bold;
    }
    .map-legend .legend-value {
        color: var(--lcars-golden-tanoi);
        text-align: right;
    }

    /* Coordinates Display */
    .coordinates-display {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(26, 26, 26, 0.95);
        border: 2px solid var(--lcars-anakiwa);
        border-radius: 6px;
        padding: 8px 12px;
        font-family: monospace;
        font-size: 13px;
        color: var(--lcars-anakiwa);
        z-index: 1000;
        pointer-events: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    .coordinates-display .coord-label {
        font-weight: bold;
        color: var(--lcars-hopbush);
    }

    /* Create Location Button */
    .create-location-btn {
        background: var(--lcars-hopbush);
        border: 2px solid var(--lcars-hopbush);
        color: white;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        font-size: 13px;
        transition: all 0.3s ease;
    }
    .create-location-btn:hover {
        background: var(--lcars-golden-tanoi);
        border-color: var(--lcars-golden-tanoi);
        color: #000;
    }
    .create-location-btn.active {
        background: var(--lcars-tanoi);
        border-color: var(--lcars-tanoi);
        animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
</style>

<header>
    <div>
        <span>Locations Map</span>
    </div>
</header>
<aside>
{{ control_switch_view }}
</aside>
<main>
<div id="map"></div>

<!-- Leaflet JS -->
<script src="/static/leaflet.js"></script>

<script>
// Wait for Leaflet to load
(function initMap() {
    if (typeof L === 'undefined') {
        setTimeout(initMap, 100);
        return;
    }

    // Check if map container exists
    const mapContainer = document.getElementById('map');
    if (!mapContainer) {
        console.error('[MAP] Map container #map not found!');
        return;
    }

    // 7D2D Projection (from Alloc's mod)
    const SDTD_Projection = {
        project: function (latlng) {
            return new L.Point(
                (latlng.lat) / Math.pow(2, 4),
                (latlng.lng) / Math.pow(2, 4)
            );
        },
        unproject: function (point) {
            return new L.LatLng(
                point.x * Math.pow(2, 4),
                point.y * Math.pow(2, 4)
            );
        }
    };

    // 7D2D CRS (from Alloc's mod)
    const SDTD_CRS = L.extend({}, L.CRS.Simple, {
        projection: SDTD_Projection,
        transformation: new L.Transformation(1, 0, -1, 0),
        scale: function (zoom) {
            return Math.pow(2, zoom);
        }
    });

    // Initialize map with 7D2D CRS
    const map = L.map('map', {
        crs: SDTD_CRS,
        center: [0, 0],
        zoom: 3,
        minZoom: -1,
        maxZoom: 7,
        attributionControl: false
    });

    // Create tile layer (Y-axis flipping handled by backend)
    const tileLayer = L.tileLayer('/map_tiles/{z}/{x}/{y}.png', {
        tileSize: 128,
        minNativeZoom: 0,
        minZoom: -1,
        maxNativeZoom: 4,
        maxZoom: 7
    }).addTo(map);

    // Storage for markers and shapes
    const locationShapes = {};
    const playerMarkers = {};

    // Helper function to create location shape based on type
    function createLocationShape(locationId, loc) {
        const coords = loc.coordinates;
        const centerLatLng = [coords.x, coords.z]; // 7D2D coordinates (x, z)
        const dims = loc.dimensions || {};
        const shape = loc.shape || 'circle';
        const isEnabled = loc.is_enabled;
        const is3D = (shape === 'box' || shape === 'spherical');

        // Color scheme
        const fillColor = isEnabled ? '#ff9900' : '#666666';
        const strokeColor = isEnabled ? '#ffcc00' : '#999999';
        const fillOpacity = isEnabled ? 0.3 : 0.15;

        let leafletShape;

        if (shape === 'circle') {
            const radius = parseFloat(dims.radius || 10);
            leafletShape = L.circle(centerLatLng, {
                radius: radius,
                fillColor: fillColor,
                color: strokeColor,
                weight: 2,
                opacity: 0.8,
                fillOpacity: fillOpacity
            });
        } else if (shape === 'spherical') {
            const radius = parseFloat(dims.radius || 10);
            leafletShape = L.circle(centerLatLng, {
                radius: radius,
                fillColor: fillColor,
                color: strokeColor,
                weight: 2,
                opacity: 0.8,
                fillOpacity: fillOpacity,
                dashArray: '5, 5' // Dashed to indicate 3D
            });
        } else if (shape === 'rectangular') {
            const width = parseFloat(dims.width || 10);
            const length = parseFloat(dims.length || 10);
            // Rectangle bounds: from center, extend width/length in both directions
            const bounds = [
                [coords.x - width, coords.z - length],
                [coords.x + width, coords.z + length]
            ];
            leafletShape = L.rectangle(bounds, {
                fillColor: fillColor,
                color: strokeColor,
                weight: 2,
                opacity: 0.8,
                fillOpacity: fillOpacity
            });
        } else if (shape === 'box') {
            const width = parseFloat(dims.width || 10);
            const length = parseFloat(dims.length || 10);
            const bounds = [
                [coords.x - width, coords.z - length],
                [coords.x + width, coords.z + length]
            ];
            leafletShape = L.rectangle(bounds, {
                fillColor: fillColor,
                color: strokeColor,
                weight: 2,
                opacity: 0.8,
                fillOpacity: fillOpacity,
                dashArray: '5, 5' // Dashed to indicate 3D
            });
        } else {
            // Fallback to circle
            leafletShape = L.circle(centerLatLng, {
                radius: 10,
                fillColor: fillColor,
                color: strokeColor,
                weight: 2,
                opacity: 0.8,
                fillOpacity: fillOpacity
            });
        }

        // Build popup content
        const dimensionText = shape === 'circle' || shape === 'spherical'
            ? 'Radius: ' + (dims.radius || 'N/A')
            : 'Width: ' + (dims.width || 'N/A') + ', Length: ' + (dims.length || 'N/A') +
              (shape === 'box' ? ', Height: ' + (dims.height || 'N/A') : '');

        // Parse locationId to extract components
        // Format: {dataset}_{owner}_{identifier}
        const locationIdParts = locationId.split('_');
        const dataset = locationIdParts.slice(0, -2).join('_'); // Handle datasets with underscores
        const owner = locationIdParts[locationIdParts.length - 2];
        const identifier = locationIdParts[locationIdParts.length - 1];

        const teleportEntry = loc.teleport_entry || {};
        const hasTeleport = teleportEntry.x !== undefined && teleportEntry.y !== undefined && teleportEntry.z !== undefined;
        const teleportText = hasTeleport
            ? 'TP: ' + (teleportEntry.x || 0).toFixed(0) + ', ' + (teleportEntry.y || 0).toFixed(0) + ', ' + (teleportEntry.z || 0).toFixed(0)
            : 'TP: Not set';

        const popupContent = '<div style="min-width: 250px; font-family: monospace;">' +
            '<b style="font-size: 1.1em;">' + loc.name + '</b>' +
            '<br><span style="font-size: 0.9em; color: #888;">' + (is3D ? 'üé≤ 3D' : '‚¨ú 2D') + ' - ' + shape + '</span>' +
            '<br><hr style="margin: 5px 0; border-color: #333;">' +
            '<b>Type:</b> ' + (loc.type && loc.type.length > 0 ? loc.type.join(', ') : 'None') +
            '<br><b>Owner:</b> ' + loc.owner +
            '<br><b>Status:</b> ' + (isEnabled ? '‚úÖ Enabled' : '‚ùå Disabled') +
            '<br><b>Position:</b> ' + coords.x.toFixed(0) + ', ' + coords.y.toFixed(0) + ', ' + coords.z.toFixed(0) +
            '<br><b>Dimensions:</b> ' + dimensionText +
            '<br><b>' + teleportText + '</b>' +
            '<br><hr style="margin: 8px 0; border-color: #333;">' +
            '<div style="display: flex; gap: 5px; justify-content: space-between; align-items: center; margin-bottom: 5px;">' +
                '<button onclick="editLocationFromMap(\'' + dataset + '\', \'' + owner + '\', \'' + identifier + '\')" ' +
                'style="flex: 1; padding: 6px 12px; background: var(--lcars-hopbush); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">' +
                '‚úèÔ∏è Edit</button>' +
                '<label style="display: flex; align-items: center; gap: 5px; cursor: pointer; white-space: nowrap;">' +
                    '<input type="checkbox" ' +
                    'id="enable_' + locationId + '" ' +
                    (isEnabled ? 'checked ' : '') +
                    'onchange="toggleLocationEnabled(\'' + dataset + '\', \'' + owner + '\', \'' + identifier + '\', this.checked)" ' +
                    'style="cursor: pointer; width: 18px; height: 18px;" /> ' +
                    '<span style="font-weight: bold;">Enabled</span>' +
                '</label>' +
            '</div>' +
            '<div style="display: flex; gap: 5px;">' +
                '<button onclick="moveLocationFromMap(\'' + locationId + '\')" ' +
                'style="flex: 1; padding: 6px 10px; background: var(--lcars-anakiwa); color: #000; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.9em;">' +
                'üìç Move</button>' +
                '<button onclick="setTeleportFromMap(\'' + locationId + '\')" ' +
                'style="flex: 1; padding: 6px 10px; background: var(--lcars-golden-tanoi); color: #000; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.9em;">' +
                'üéØ Set TP</button>' +
            '</div>' +
            '</div>';

        leafletShape.bindPopup(popupContent);
        leafletShape.addTo(map);

        return leafletShape;
    }

    // Add location shapes
    const locations = {{ locations_json|safe }};

    Object.keys(locations).forEach(function(locationId) {
        const loc = locations[locationId];
        try {
            const shape = createLocationShape(locationId, loc);
            locationShapes[locationId] = shape;
        } catch (error) {
            console.error('[MAP] Error creating shape for location ' + locationId + ':', error);
        }
    });

    // Add player markers
    const players = {{ players_json|safe }};

    Object.keys(players).forEach(function(steamid) {
        const player = players[steamid];
        if (player.pos) {
            const coords = [player.pos.x, player.pos.z];

            const marker = L.circleMarker(coords, {
                radius: 5,
                fillColor: '#66ccff',
                color: '#0099ff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9,
                className: 'player-marker'
            }).addTo(map);

            marker.bindPopup('<b>' + player.name + '</b><br>Level: ' + player.level);
            playerMarkers[steamid] = marker;
        }
    });

    // Remove old map handler if it exists from previous view load
    if (window.mapDataHandler) {
        window.socket.off('data', window.mapDataHandler);
    }

    // Create NEW handler function that captures current local scope
    // This must be recreated each time to access current locationShapes/playerMarkers
    window.mapDataHandler = function(data) {
        if (data.data_type === 'player_position_update') {
            const steamid = data.steamid;
            const pos = data.position;

            if (playerMarkers[steamid]) {
                // Update existing marker
                playerMarkers[steamid].setLatLng([pos.x, pos.z]);
            } else if (pos) {
                // Create new marker
                const marker = L.circleMarker([pos.x, pos.z], {
                    radius: 5,
                    fillColor: '#66ccff',
                    color: '#0099ff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.9,
                    className: 'player-marker'
                }).addTo(map);

                marker.bindPopup('<b>' + (data.name || 'Player') + '</b>');
                playerMarkers[steamid] = marker;
            }
        }

        // Listen for location updates/additions
        if (data.data_type === 'location_update' && data.location) {
            const locationId = data.location_id;
            const loc = data.location;

            // Remove old shape if exists
            if (locationShapes[locationId]) {
                map.removeLayer(locationShapes[locationId]);
                delete locationShapes[locationId];
            }

            // Create new shape
            try {
                const shape = createLocationShape(locationId, loc);
                locationShapes[locationId] = shape;
            } catch (error) {
                console.error('[MAP] Error updating location shape:', error);
            }
        }

        // Listen for location removals
        if (data.data_type === 'location_remove' && data.location_id) {
            const locationId = data.location_id;

            if (locationShapes[locationId]) {
                map.removeLayer(locationShapes[locationId]);
                delete locationShapes[locationId];
            }
        }
    };

    // Register the new handler
    window.socket.on('data', window.mapDataHandler);

    // Fit map to show all markers and shapes on load
    const allMapObjects = Object.values(locationShapes).concat(Object.values(playerMarkers));

    if (allMapObjects.length > 0) {
        const group = L.featureGroup(allMapObjects);
        map.fitBounds(group.getBounds().pad(0.1));
    }

    // Fix map size after a short delay (in case container was hidden initially)
    setTimeout(function() {
        map.invalidateSize();
    }, 250);

    // ========================================
    // FEATURE 1: Map Legend with Metadata
    // ========================================
    const gameprefs = {{ gameprefs_json|safe }};
    const activeDataset = "{{ active_dataset }}";

    // Create custom legend control
    const legend = L.control({position: 'topleft'});

    legend.onAdd = function (map) {
        const div = L.DomUtil.create('div', 'map-legend');

        // Extract relevant gameprefs
        const gameName = gameprefs['GameName'] || activeDataset;
        const gameWorld = gameprefs['GameWorld'] || 'N/A';
        const worldGenSeed = gameprefs['WorldGenSeed'] || 'N/A';
        const worldGenSize = gameprefs['WorldGenSize'] || 'N/A';

        // Build legend content
        div.innerHTML = '<h4>üó∫Ô∏è Map Info</h4>' +
            '<div class="legend-item">' +
                '<span class="legend-label">World:</span>' +
                '<span class="legend-value">' + gameName + '</span>' +
            '</div>' +
            '<div class="legend-item">' +
                '<span class="legend-label">Type:</span>' +
                '<span class="legend-value">' + gameWorld + '</span>' +
            '</div>' +
            '<div class="legend-item">' +
                '<span class="legend-label">Size:</span>' +
                '<span class="legend-value">' + worldGenSize + '</span>' +
            '</div>' +
            '<div class="legend-item">' +
                '<span class="legend-label">Seed:</span>' +
                '<span class="legend-value">' + worldGenSeed + '</span>' +
            '</div>' +
            '<div class="legend-item">' +
                '<span class="legend-label">Locations:</span>' +
                '<span class="legend-value">' + Object.keys(locations).length + '</span>' +
            '</div>' +
            '<div class="legend-item">' +
                '<span class="legend-label">Players:</span>' +
                '<span class="legend-value">' + Object.keys(players).length + '</span>' +
            '</div>';

        return div;
    };

    legend.addTo(map);

    // ========================================
    // FEATURE 2: Coordinates Under Mouse Cursor
    // ========================================

    // Create coordinates display element
    const coordsDiv = L.DomUtil.create('div', 'coordinates-display');
    coordsDiv.innerHTML = '<span class="coord-label">X:</span> <span id="coord-x">0</span> | ' +
                         '<span class="coord-label">Z:</span> <span id="coord-z">0</span>';
    document.getElementById('map').appendChild(coordsDiv);

    // Update coordinates on mouse move
    map.on('mousemove', function(e) {
        const coords = e.latlng;
        // In 7D2D, lat corresponds to X and lng to Z
        document.getElementById('coord-x').textContent = Math.round(coords.lat);
        document.getElementById('coord-z').textContent = Math.round(coords.lng);
    });

    // ========================================
    // FEATURE 3: Create Location UI
    // ========================================

    // Store tempMarker globally so it can be accessed by confirm/cancel functions
    let tempMarker = null;

    // Create custom control for location creation
    const createLocationControl = L.control({position: 'topright'});

    createLocationControl.onAdd = function (mapInstance) {
        const btn = L.DomUtil.create('button', 'create-location-btn');
        btn.innerHTML = 'üìç Create Location';
        btn.title = 'Click to enable location creation mode';

        // Prevent map interactions when clicking the button
        L.DomEvent.disableClickPropagation(btn);

        let creationMode = false;

        btn.onclick = function() {
            creationMode = !creationMode;

            if (creationMode) {
                btn.classList.add('active');
                btn.innerHTML = '‚úñÔ∏è Cancel';
                map.getContainer().style.cursor = 'crosshair';

                // Add click handler for location creation
                map.once('click', function(e) {
                    const coords = e.latlng;
                    const x = Math.round(coords.lat);
                    const z = Math.round(coords.lng);

                    // Create temporary marker
                    tempMarker = L.circleMarker([coords.lat, coords.lng], {
                        radius: 8,
                        fillColor: '#ff00ff',
                        color: '#ff00ff',
                        weight: 3,
                        opacity: 1,
                        fillOpacity: 0.6
                    }).addTo(map);

                    tempMarker.bindPopup(
                        '<div style="text-align: center;">' +
                        '<b>New Location</b><br>' +
                        'X: ' + x + ', Z: ' + z + '<br>' +
                        '<button onclick="confirmLocation(' + x + ', ' + z + ')" ' +
                        'style="margin: 5px; padding: 5px 10px; background: var(--lcars-hopbush); color: white; border: none; border-radius: 4px; cursor: pointer;">' +
                        'Create Here</button>' +
                        '<button onclick="cancelLocation()" ' +
                        'style="margin: 5px; padding: 5px 10px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">' +
                        'Cancel</button>' +
                        '</div>'
                    ).openPopup();

                    // Reset button state
                    btn.classList.remove('active');
                    btn.innerHTML = 'üìç Create Location';
                    map.getContainer().style.cursor = '';
                    creationMode = false;
                });
            } else {
                btn.classList.remove('active');
                btn.innerHTML = 'üìç Create Location';
                map.getContainer().style.cursor = '';

                // Remove temp marker if exists
                if (tempMarker) {
                    map.removeLayer(tempMarker);
                    tempMarker = null;
                }
            }
        };

        return btn;
    };

    createLocationControl.addTo(map);

    // Global functions for location creation confirmation
    window.confirmLocation = function(x, z) {
        // Navigate to create_new view with pre-filled coordinates using WebSocket
        // This follows the exact same pattern as all other action calls in the system
        window.socket.emit(
            'widget_event',                    // Socket event name
            ['locations',                      // Module identifier
             ['toggle_locations_widget_view',  // Action identifier
              {                                // Action parameters
                  'action': 'show_create_new',
                  'prefill_x': x,
                  'prefill_z': z,
                  'prefill_y': 0              // Default Y coordinate
              }]]
        );

        console.log('[MAP] Navigating to create location form with coordinates:', x, z);

        // Remove temp marker
        if (tempMarker) {
            map.removeLayer(tempMarker);
            tempMarker = null;
        }
    };

    window.cancelLocation = function() {
        // Remove temp marker
        if (tempMarker) {
            map.removeLayer(tempMarker);
            tempMarker = null;
        }
    };

    // ========================================
    // FEATURE 4: Edit & Enable from Map Popup
    // ========================================

    // Edit location from map popup
    window.editLocationFromMap = function(dataset, owner, identifier) {
        // This follows the exact same pattern as control_edit_link.html
        window.socket.emit(
            'widget_event',
            ['locations',
             ['toggle_locations_widget_view', {
                 'dom_element_owner': owner,
                 'dom_element_identifier': identifier,
                 'dom_element_origin': dataset,
                 'action': 'edit_location_entry'
             }]]
        );
        console.log('[MAP] Opening edit view for location:', identifier);
    };

    // Toggle enabled status from map popup
    window.toggleLocationEnabled = function(dataset, owner, identifier, isChecked) {
        // This follows the exact same pattern as control_enabled_link.html
        const action = isChecked ? 'enable_location_entry' : 'disable_location_entry';

        window.socket.emit(
            'widget_event',
            ['locations',
             ['toggle_enabled_flag', {
                 'dom_element_owner': owner,
                 'dom_element_identifier': identifier,
                 'dom_element_origin': dataset,
                 'action': action
             }]]
        );
        console.log('[MAP] Toggling location enabled status:', identifier, 'to', isChecked);
    };

    // ========================================
    // FEATURE 5: Move Location & Set Teleport
    // ========================================

    // Move location to new position (relative teleport)
    window.moveLocationFromMap = function(locationId) {
        const loc = locations[locationId];
        if (!loc) {
            console.error('[MAP] Location not found:', locationId);
            return;
        }

        // Close any open popups
        map.closePopup();

        // Create info message
        const infoDiv = L.DomUtil.create('div', 'coordinates-display');
        infoDiv.style.bottom = '50px';
        infoDiv.style.background = 'rgba(102, 204, 255, 0.95)';
        infoDiv.style.borderColor = 'var(--lcars-anakiwa)';
        infoDiv.style.color = '#000';
        infoDiv.style.fontWeight = 'bold';
        infoDiv.innerHTML = 'üìç Click new location position on map';
        document.getElementById('map').appendChild(infoDiv);

        // Change cursor
        map.getContainer().style.cursor = 'crosshair';

        // Wait for click
        map.once('click', function(e) {
            const newCoords = e.latlng;
            const newX = Math.round(newCoords.lat);
            const newZ = Math.round(newCoords.lng);

            // Calculate offset
            const offsetX = newX - loc.coordinates.x;
            const offsetZ = newZ - loc.coordinates.z;

            // Move teleport_entry relatively if it exists
            let newTeleportEntry = loc.teleport_entry || {};
            if (newTeleportEntry.x !== undefined && newTeleportEntry.y !== undefined && newTeleportEntry.z !== undefined) {
                newTeleportEntry = {
                    x: (parseFloat(newTeleportEntry.x) || 0) + offsetX,
                    y: parseFloat(newTeleportEntry.y) || 0, // Y stays same
                    z: (parseFloat(newTeleportEntry.z) || 0) + offsetZ
                };
            }

            // Call edit_location with ALL fields
            window.socket.emit(
                'widget_event',
                ['locations',
                 ['edit_location', {
                     'location_identifier': loc.identifier,
                     'location_name': loc.name,
                     'location_shape': loc.shape,
                     'location_type': loc.type || [],
                     'location_coordinates': {
                         'x': newX,
                         'y': loc.coordinates.y,
                         'z': newZ
                     },
                     'location_teleport_entry': newTeleportEntry,
                     'location_dimensions': loc.dimensions || {},
                     'location_owner': loc.owner,
                     'is_enabled': loc.is_enabled
                 }]]
            );

            console.log('[MAP] Moved location to:', newX, newZ, 'Offset:', offsetX, offsetZ);

            // Cleanup
            map.getContainer().style.cursor = '';
            document.getElementById('map').removeChild(infoDiv);
        });
    };

    // Set teleport coordinates
    window.setTeleportFromMap = function(locationId) {
        const loc = locations[locationId];
        if (!loc) {
            console.error('[MAP] Location not found:', locationId);
            return;
        }

        // Close any open popups
        map.closePopup();

        // Create info message
        const infoDiv = L.DomUtil.create('div', 'coordinates-display');
        infoDiv.style.bottom = '50px';
        infoDiv.style.background = 'rgba(255, 153, 0, 0.95)';
        infoDiv.style.borderColor = 'var(--lcars-golden-tanoi)';
        infoDiv.style.color = '#000';
        infoDiv.style.fontWeight = 'bold';
        infoDiv.innerHTML = 'üéØ Click teleport destination on map';
        document.getElementById('map').appendChild(infoDiv);

        // Change cursor
        map.getContainer().style.cursor = 'crosshair';

        // Wait for click
        map.once('click', function(e) {
            const teleportCoords = e.latlng;
            const tpX = Math.round(teleportCoords.lat);
            const tpZ = Math.round(teleportCoords.lng);

            // Use current Y coordinate or default to location Y
            const tpY = (loc.teleport_entry && loc.teleport_entry.y) || loc.coordinates.y;

            // Call edit_location with ALL fields
            window.socket.emit(
                'widget_event',
                ['locations',
                 ['edit_location', {
                     'location_identifier': loc.identifier,
                     'location_name': loc.name,
                     'location_shape': loc.shape,
                     'location_type': loc.type || [],
                     'location_coordinates': loc.coordinates,
                     'location_teleport_entry': {
                         'x': tpX,
                         'y': tpY,
                         'z': tpZ
                     },
                     'location_dimensions': loc.dimensions || {},
                     'location_owner': loc.owner,
                     'is_enabled': loc.is_enabled
                 }]]
            );

            console.log('[MAP] Set teleport to:', tpX, tpY, tpZ);

            // Cleanup
            map.getContainer().style.cursor = '';
            document.getElementById('map').removeChild(infoDiv);
        });
    };

})();
</script>
</main>
