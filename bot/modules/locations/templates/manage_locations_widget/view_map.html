<!-- Leaflet CSS -->
<link rel="stylesheet" href="/static/leaflet.css"/>

<style>
    #map {
        width: 100%;
        height: 100%;
        min-height: 400px;
        background: #1a1a1a;
        border: 2px solid var(--lcars-hopbush);
        border-radius: 8px;
        box-sizing: border-box;
    }
    main {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
    }
    .leaflet-container {
        background: #1a1a1a;
    }
    .location-marker {
        background-color: var(--lcars-golden-tanoi);
        border: 2px solid var(--lcars-tanoi);
        border-radius: 50%;
        width: 12px;
        height: 12px;
    }
    .player-marker {
        background-color: var(--lcars-anakiwa);
        border: 2px solid var(--lcars-mariner);
        border-radius: 50%;
        width: 10px;
        height: 10px;
    }
    .map-controls {
        margin-bottom: 10px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
    }
</style>

<header>
    <div>
        <span>Locations Map</span>
    </div>
</header>
<aside>
{{ control_switch_view }}
</aside>
<main>
<div id="map"></div>

<!-- Leaflet JS -->
<script src="/static/leaflet.js"></script>

<script>
// Wait for Leaflet to load
(function initMap() {
    if (typeof L === 'undefined') {
        console.log('Waiting for Leaflet to load...');
        setTimeout(initMap, 100);
        return;
    }

    console.log('[MAP] Initializing 7D2D map...');

    // Check if map container exists
    const mapContainer = document.getElementById('map');
    if (!mapContainer) {
        console.error('[MAP] Map container #map not found!');
        return;
    }
    console.log('[MAP] Map container found:', mapContainer);

    // 7D2D Projection (from Alloc's mod)
    const SDTD_Projection = {
        project: function (latlng) {
            return new L.Point(
                (latlng.lat) / Math.pow(2, 4),
                (latlng.lng) / Math.pow(2, 4)
            );
        },
        unproject: function (point) {
            return new L.LatLng(
                point.x * Math.pow(2, 4),
                point.y * Math.pow(2, 4)
            );
        }
    };

    // 7D2D CRS (from Alloc's mod)
    const SDTD_CRS = L.extend({}, L.CRS.Simple, {
        projection: SDTD_Projection,
        transformation: new L.Transformation(1, 0, -1, 0),
        scale: function (zoom) {
            return Math.pow(2, zoom);
        }
    });

    // Initialize map with 7D2D CRS
    console.log('[MAP] Creating Leaflet map instance...');
    const map = L.map('map', {
        crs: SDTD_CRS,
        center: [0, 0],
        zoom: 3,
        minZoom: -1,
        maxZoom: 7,
        attributionControl: false
    });
    console.log('[MAP] Map instance created');

    // Create tile layer (Y-axis flipping handled by backend)
    const tileLayer = L.tileLayer('/map_tiles/{z}/{x}/{y}.png', {
        tileSize: 128,
        minNativeZoom: 0,
        minZoom: -1,
        maxNativeZoom: 4,
        maxZoom: 7
    }).addTo(map);

    // Storage for markers and shapes
    const locationShapes = {};
    const playerMarkers = {};

    // Helper function to create location shape based on type
    function createLocationShape(locationId, loc) {
        const coords = loc.coordinates;
        const centerLatLng = [coords.x, coords.z]; // 7D2D coordinates (x, z)
        const dims = loc.dimensions || {};
        const shape = loc.shape || 'circle';
        const isEnabled = loc.is_enabled;
        const is3D = (shape === 'box' || shape === 'spherical');

        // Color scheme
        const fillColor = isEnabled ? '#ff9900' : '#666666';
        const strokeColor = isEnabled ? '#ffcc00' : '#999999';
        const fillOpacity = isEnabled ? 0.3 : 0.15;

        let leafletShape;

        if (shape === 'circle') {
            const radius = parseFloat(dims.radius || 10);
            leafletShape = L.circle(centerLatLng, {
                radius: radius,
                fillColor: fillColor,
                color: strokeColor,
                weight: 2,
                opacity: 0.8,
                fillOpacity: fillOpacity
            });
        } else if (shape === 'spherical') {
            const radius = parseFloat(dims.radius || 10);
            leafletShape = L.circle(centerLatLng, {
                radius: radius,
                fillColor: fillColor,
                color: strokeColor,
                weight: 2,
                opacity: 0.8,
                fillOpacity: fillOpacity,
                dashArray: '5, 5' // Dashed to indicate 3D
            });
        } else if (shape === 'rectangular') {
            const width = parseFloat(dims.width || 10);
            const length = parseFloat(dims.length || 10);
            // Rectangle bounds: from center, extend width/length in both directions
            const bounds = [
                [coords.x - width, coords.z - length],
                [coords.x + width, coords.z + length]
            ];
            leafletShape = L.rectangle(bounds, {
                fillColor: fillColor,
                color: strokeColor,
                weight: 2,
                opacity: 0.8,
                fillOpacity: fillOpacity
            });
        } else if (shape === 'box') {
            const width = parseFloat(dims.width || 10);
            const length = parseFloat(dims.length || 10);
            const bounds = [
                [coords.x - width, coords.z - length],
                [coords.x + width, coords.z + length]
            ];
            leafletShape = L.rectangle(bounds, {
                fillColor: fillColor,
                color: strokeColor,
                weight: 2,
                opacity: 0.8,
                fillOpacity: fillOpacity,
                dashArray: '5, 5' // Dashed to indicate 3D
            });
        } else {
            // Fallback to circle
            leafletShape = L.circle(centerLatLng, {
                radius: 10,
                fillColor: fillColor,
                color: strokeColor,
                weight: 2,
                opacity: 0.8,
                fillOpacity: fillOpacity
            });
        }

        // Build popup content
        const dimensionText = shape === 'circle' || shape === 'spherical'
            ? 'Radius: ' + (dims.radius || 'N/A')
            : 'Width: ' + (dims.width || 'N/A') + ', Length: ' + (dims.length || 'N/A') +
              (shape === 'box' ? ', Height: ' + (dims.height || 'N/A') : '');

        const popupContent = '<div style="min-width: 200px;">' +
            '<b>' + loc.name + '</b>' +
            '<br><span style="font-size: 0.9em; color: #888;">' + (is3D ? 'üé≤ 3D' : '‚¨ú 2D') + ' - ' + shape + '</span>' +
            '<br><hr style="margin: 5px 0; border-color: #333;">' +
            '<b>Type:</b> ' + (loc.type && loc.type.length > 0 ? loc.type.join(', ') : 'None') +
            '<br><b>Owner:</b> ' + loc.owner +
            '<br><b>Status:</b> ' + (isEnabled ? '‚úÖ Enabled' : '‚ùå Disabled') +
            '<br><b>Position:</b> ' + coords.x.toFixed(0) + ', ' + coords.y.toFixed(0) + ', ' + coords.z.toFixed(0) +
            '<br><b>Dimensions:</b> ' + dimensionText +
            '</div>';

        leafletShape.bindPopup(popupContent);
        leafletShape.addTo(map);

        return leafletShape;
    }

    // Add location shapes
    const locations = {{ locations_json|safe }};
    console.log('[MAP] Locations data:', locations);
    console.log('[MAP] Number of locations:', Object.keys(locations).length);

    Object.keys(locations).forEach(function(locationId) {
        const loc = locations[locationId];
        try {
            const shape = createLocationShape(locationId, loc);
            locationShapes[locationId] = shape;
        } catch (error) {
            console.error('[MAP] Error creating shape for location ' + locationId + ':', error);
        }
    });

    // Add player markers
    const players = {{ players_json|safe }};
    console.log('[MAP] Players data:', players);
    console.log('[MAP] Number of players:', Object.keys(players).length);

    Object.keys(players).forEach(function(steamid) {
        const player = players[steamid];
        if (player.pos) {
            const coords = [player.pos.x, player.pos.z];

            const marker = L.circleMarker(coords, {
                radius: 5,
                fillColor: '#66ccff',
                color: '#0099ff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9,
                className: 'player-marker'
            }).addTo(map);

            marker.bindPopup('<b>' + player.name + '</b><br>Level: ' + player.level);
            playerMarkers[steamid] = marker;
        }
    });

    // Create named handler function for map events
    // This allows us to remove it specifically without affecting other listeners
    function mapDataHandler(data) {
        if (data.data_type === 'player_position_update') {
            const steamid = data.steamid;
            const pos = data.position;

            if (playerMarkers[steamid]) {
                // Update existing marker
                playerMarkers[steamid].setLatLng([pos.x, pos.z]);
            } else if (pos) {
                // Create new marker
                const marker = L.circleMarker([pos.x, pos.z], {
                    radius: 5,
                    fillColor: '#66ccff',
                    color: '#0099ff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.9,
                    className: 'player-marker'
                }).addTo(map);

                marker.bindPopup('<b>' + (data.name || 'Player') + '</b>');
                playerMarkers[steamid] = marker;
            }
        }

        // Listen for location updates/additions
        if (data.data_type === 'location_update' && data.location) {
            const locationId = data.location_id;
            const loc = data.location;

            console.log('[MAP] Location update received:', locationId, loc);

            // Remove old shape if exists
            if (locationShapes[locationId]) {
                map.removeLayer(locationShapes[locationId]);
                delete locationShapes[locationId];
            }

            // Create new shape
            try {
                const shape = createLocationShape(locationId, loc);
                locationShapes[locationId] = shape;
            } catch (error) {
                console.error('[MAP] Error updating location shape:', error);
            }
        }

        // Listen for location removals
        if (data.data_type === 'location_remove' && data.location_id) {
            const locationId = data.location_id;
            console.log('[MAP] Location removal received:', locationId);

            if (locationShapes[locationId]) {
                map.removeLayer(locationShapes[locationId]);
                delete locationShapes[locationId];
            }
        }
    }

    // Remove old map event listener if it exists, then register the new one
    // This prevents accumulation of duplicate listeners on view switches
    window.socket.off('data', mapDataHandler);
    window.socket.on('data', mapDataHandler);

    // Fit map to show all markers and shapes on load
    const allMapObjects = Object.values(locationShapes).concat(Object.values(playerMarkers));
    console.log('[MAP] Total map objects:', allMapObjects.length);

    if (allMapObjects.length > 0) {
        const group = L.featureGroup(allMapObjects);
        map.fitBounds(group.getBounds().pad(0.1));
        console.log('[MAP] Map fitted to bounds');
    } else {
        console.log('[MAP] No map objects to display, using default center');
    }

    console.log('[MAP] Map initialization complete!');

    // Fix map size after a short delay (in case container was hidden initially)
    setTimeout(function() {
        map.invalidateSize();
        console.log('[MAP] Map size invalidated/refreshed');
    }, 250);
})();
</script>
</main>
