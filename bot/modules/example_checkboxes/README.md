# Example Module: Checkbox Table Widget

This module demonstrates the **complete pattern** for creating tables with selectable checkboxes in the bot. Use this as a reference/template for new modules!

## üéØ What This Demonstrates

1. **DOM Structure** - How to store selectable elements
2. **Checkbox Selection** - Using `dom_management.get_selection_dom_element()`
3. **Reactive Updates** - DOM callbacks for real-time updates
4. **Component Templates** - Proper micro-template architecture
5. **Handler Registration** - Correct paths and patterns

---

## üìÅ File Structure

```
bot/modules/example_checkboxes/
‚îú‚îÄ‚îÄ __init__.py                           # Module initialization
‚îú‚îÄ‚îÄ README.md                             # This file
‚îú‚îÄ‚îÄ widgets/
‚îÇ   ‚îî‚îÄ‚îÄ checkbox_widget.py                # Widget with all handlers
‚îî‚îÄ‚îÄ templates/
    ‚îî‚îÄ‚îÄ checkbox_widget/
        ‚îú‚îÄ‚îÄ view_main.html                # Main view
        ‚îú‚îÄ‚îÄ table_header.html             # Table header
        ‚îú‚îÄ‚îÄ table_row.html                # Table row (with checkbox)
        ‚îî‚îÄ‚îÄ table_footer.html             # Table footer
```

---

## üèóÔ∏è Architecture Overview

### 1. DOM Structure (CRITICAL!)

**All selectable elements MUST be stored under `{module}/elements/`:**

```
module_example_checkboxes/
  elements/                          # ‚Üê MUST be called "elements"!
    {dataset}/                       # e.g., "example_dataset"
      {item_id}/                     # e.g., "item_001"
        id: "item_001"
        owner: "item_001"            # Usually same as item_id
        identifier: "item_001"       # Usually same as item_id
        name: "Example Item 1"       # Display data
        description: "..."           # Any other data
        dataset: "example_dataset"   # Dataset name
        selected_by: []              # List of steamids
```

**Why `elements`?**
The `dom_management/select` action hardcodes the path:
```python
general_root = [target_module, "elements", dom_element_origin, dom_element_owner]
```

### 2. Required Fields

Each item MUST have these fields for checkboxes to work:

| Field | Type | Description |
|-------|------|-------------|
| `id` | str | Unique identifier |
| `owner` | str | Usually same as `id` |
| `identifier` | str | Usually same as `id` |
| `dataset` | str | Dataset name (e.g., map name) |
| `selected_by` | list | Empty list `[]` initially |

You can add any other fields you need (name, description, etc.)

### 3. Handler Paths

Register three handlers in `widget_meta`:

```python
"handlers": {
    # Handler for new/updated items
    "module_example_checkboxes/elements/%dataset%/%element_identifier%":
        table_rows,

    # Handler for checkbox clicks (selection changes)
    "module_example_checkboxes/elements/%dataset%/%element_identifier%/selected_by":
        update_selection_status,
}
```

---

## üîÑ Data Flow

### When User Clicks Checkbox:

```
1. Browser
   ‚Üì socket.emit('widget_event', ['dom_management', ['select', {
       'dom_element_select_root': ['selected_by'],
       'target_module': 'module_example_checkboxes',
       'dom_element_owner': 'item_001',
       'dom_element_identifier': 'item_001',
       'dom_element_origin': 'example_dataset',
       'action': 'select_dom_element'
     }]])

2. dom_management/select action
   ‚Üì Updates: module_example_checkboxes/elements/example_dataset/item_001/selected_by
   ‚Üì Adds/removes steamid from selected_by list

3. DOM Callback System
   ‚Üì Detects change at: .../selected_by
   ‚Üì Finds handler: update_selection_status

4. update_selection_status()
   ‚Üì Calls: dom_management.update_selection_status()
   ‚Üì Re-renders ONLY the checkbox span

5. Browser
   ‚úì Checkbox updates (checkmark appears/disappears)
```

---

## üé® Template Pattern

### Component-Based Structure

**Main View** (`view_main.html`):
```html
<table>
  <thead>{{ table_header }}</thead>
  <tbody id="checkbox_table">{{ table_rows }}</tbody>
  <tfoot>{{ table_footer }}</tfoot>
</table>
```

**Table Row** (`table_row.html`):
```html
<tr id="checkbox_table_row_{{ item.dataset }}_{{ item.id }}">
  <td>
    <span id="checkbox_table_row_{{ item.dataset }}_{{ item.id }}_control_select_link">
      {{ control_select_link }}
    </span>
  </td>
  <td>{{ item.name }}</td>
  <td>{{ item.description }}</td>
</tr>
```

**Key Points:**
- Each row has unique ID: `{prefix}_{{ item.dataset }}_{{ item.id }}`
- Checkbox span has ID: `{row_id}_control_select_link`
- The `control_select_link` is generated by `dom_management.get_selection_dom_element()`

---

## üìù Widget Code Pattern

### 1. Initial View Rendering

```python
def select_view(*args, **kwargs):
    module = args[0]
    dispatchers_steamid = kwargs.get('dispatchers_steamid', None)

    # Load templates
    template_main = module.templates.get_template('checkbox_widget/view_main.html')
    template_table_row = module.templates.get_template('checkbox_widget/table_row.html')

    # Get elements from DOM
    all_elements = module.dom.data.get("module_example_checkboxes", {}).get("elements", {})

    table_rows_list = []
    for dataset, items in all_elements.items():
        for item_id, item_data in items.items():
            # Check if selected by current user
            item_is_selected_by = item_data.get("selected_by", [])
            item_entry_selected = dispatchers_steamid in item_is_selected_by

            # CRITICAL: Generate control FIRST with original data
            control_select_link = module.dom_management.get_selection_dom_element(
                module,
                target_module="module_example_checkboxes",
                dom_element_select_root=["selected_by"],  # Just ["selected_by"]!
                dom_element=item_data,
                dom_element_entry_selected=item_entry_selected,
                dom_action_inactive="select_dom_element",
                dom_action_active="deselect_dom_element"
            )

            # THEN sanitize data for template
            item_dict_for_template = item_data.copy()
            item_dict_for_template["dataset"] = module.dom_management.sanitize_for_html_id(dataset)

            # Render row
            rendered_row = module.template_render_hook(
                module,
                template=template_table_row,
                item=item_dict_for_template,
                control_select_link=control_select_link
            )
            table_rows_list.append(rendered_row)

    # ... render and send to client
```

**Critical Order:**
1. Generate `control_select_link` with **original** `item_data`
2. **Then** create sanitized template dict
3. Render row with both

### 2. Dynamic Row Updates

```python
def table_rows(*args, **kwargs):
    module = args[0]
    updated_values_dict = kwargs.get("updated_values_dict", None)
    method = kwargs.get("method", None)

    if method in ["upsert", "edit", "insert", "update"]:
        for clientid in module.webserver.connected_clients.keys():
            for item_id, item_data in updated_values_dict.items():
                # Same pattern as above...

                module.webserver.send_data_to_client_hook(
                    module,
                    payload=table_row,
                    data_type="table_row",  # ‚Üê Important!
                    clients=[clientid],
                    target_element={
                        "id": "checkbox_table_row_{}_{}".format(sanitized_dataset, item_id),
                        "type": "tr",
                        "selector": "body > main > div > ... > tbody#checkbox_table"
                    }
                )
```

### 3. Selection Status Updates

```python
def update_selection_status(*args, **kwargs):
    module = args[0]
    updated_values_dict = kwargs.get("updated_values_dict", None)

    sanitized_dataset = module.dom_management.sanitize_for_html_id(
        updated_values_dict["dataset"]
    )

    # Call helper - it handles everything
    module.dom_management.update_selection_status(
        *args, **kwargs,
        target_module=module,
        dom_action_active="deselect_dom_element",
        dom_action_inactive="select_dom_element",
        dom_element_id={
            "id": "checkbox_table_row_{}_{}_control_select_link".format(
                sanitized_dataset,
                updated_values_dict["identifier"]
            )
        }
    )
```

---

## üöÄ How to Use This Example

### 1. Enable the Module

Add to your config:
```python
"module_example_checkboxes": {
    "enabled": true
}
```

### 2. Access the Widget

Navigate to: `http://your-bot:5000/` (if webserver is configured to serve this widget)

### 3. Test Functionality

- Click checkboxes ‚Üí they should toggle instantly
- Open multiple browser tabs ‚Üí selections are per-user
- Check logs ‚Üí see DOM updates in real-time

### 4. Use as Template

When creating a new module with checkboxes:

1. **Copy this module structure**
2. **Replace `example_checkboxes` with your module name** in:
   - Directory names
   - `__init__.py` ‚Üí class name and identifiers
   - `checkbox_widget.py` ‚Üí all references
   - Handler paths in `widget_meta`
3. **Modify data structure** in `__init__.py` ‚Üí `start()`
4. **Customize templates** for your data
5. **Keep the checkbox pattern identical!**

---

## ‚ö†Ô∏è Common Pitfalls

### ‚ùå Wrong DOM Path
```python
# WRONG - will not work with checkboxes!
self.dom.data.upsert({
    "module_example": {
        "my_items": {  # ‚Üê Should be "elements"!
            ...
        }
    }
})
```

### ‚úÖ Correct DOM Path
```python
# CORRECT
self.dom.data.upsert({
    "module_example": {
        "elements": {  # ‚Üê Must be "elements"!
            ...
        }
    }
})
```

### ‚ùå Wrong dom_element_select_root
```python
# WRONG - full path
control_select_link = module.dom_management.get_selection_dom_element(
    ...,
    dom_element_select_root=["elements", dataset, item_id, "selected_by"],  # ‚Üê Too long!
    ...
)
```

### ‚úÖ Correct dom_element_select_root
```python
# CORRECT - just ["selected_by"]
control_select_link = module.dom_management.get_selection_dom_element(
    ...,
    dom_element_select_root=["selected_by"],  # ‚Üê Perfect!
    ...
)
```

### ‚ùå Sanitizing Before Control Generation
```python
# WRONG - control won't work!
item_data["dataset"] = sanitize_for_html_id(item_data["dataset"])  # ‚Üê Modifies original!
control_select_link = get_selection_dom_element(..., dom_element=item_data)  # ‚Üê Will fail!
```

### ‚úÖ Correct Order
```python
# CORRECT - control first, then sanitize
control_select_link = get_selection_dom_element(..., dom_element=item_data)  # ‚Üê Original data!
item_template = item_data.copy()  # ‚Üê Make copy!
item_template["dataset"] = sanitize_for_html_id(item_data["dataset"])  # ‚Üê Sanitize copy!
```

---

## üêõ Debugging

If checkboxes don't work:

1. **Check Browser Console** (F12)
   - Look for JavaScript errors
   - Check if `onclick` handlers are present

2. **Check Logs**
   - Should see: `received status "success:..." for action "select"`
   - Should see handler calls in bot logs

3. **Check DOM Structure**
   - Verify: `module_example_checkboxes/elements/{dataset}/{id}/selected_by` exists
   - Check: Item has `owner`, `identifier`, `dataset` fields

4. **Check Handler Paths**
   - Must match: `module_name/elements/%dataset%/%element_identifier%/selected_by`

5. **Check HTML IDs**
   - Row ID: `{prefix}_{sanitized_dataset}_{item_id}`
   - Control ID: `{row_id}_control_select_link`
   - Must match what `update_selection_status` expects!

---

## üìö Related Modules

Study these modules for more examples:
- `bot/modules/game_environment/widgets/manage_entities_widget.py` - Entities with checkboxes
- `bot/modules/locations/widgets/manage_locations_widget.py` - Locations with checkboxes
- `bot/modules/players/widgets/manage_players_widget.py` - Players with checkboxes

---

## üí° Tips

1. **Always use `elements`** in DOM path - it's required by `dom_management`
2. **Generate control_select_link before sanitizing** - use original data
3. **Match HTML IDs exactly** - use same pattern in template and handler
4. **Include all required fields** - id, owner, identifier, dataset, selected_by
5. **Test in multiple browsers** - each user gets independent selections
6. **Check logs** - enable debug logging to see exactly what's happening

---

## üéì Learning Resources

1. Read this README completely
2. Study the code in `checkbox_widget.py` - it has detailed comments
3. Look at the templates - understand the ID pattern
4. Run the module and click checkboxes
5. Watch the browser console and bot logs
6. Compare with `manage_entities_widget.py` for a production example

---

**Questions?** Check the bot's main documentation or study the related modules mentioned above.

**Found a bug?** This is a reference implementation - feel free to improve it!
